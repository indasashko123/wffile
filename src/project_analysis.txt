СТРУКТУРА ПРОЕКТА:
==================
.
└── .
    ├── core
    │   ├── application
    │   │   ├── common
    │   │   │   ├── events
    │   │   │   └── exceptions
    │   │   ├── config
    │   │   ├── dto
    │   │   │   ├── request
    │   │   │   └── response
    │   │   ├── interfaces
    │   │   └── services
    │   └── domain
    │       ├── auth
    │       │   ├── dto
    │       │   ├── entities
    │       │   ├── repositories
    │       │   └── use-cases
    │       ├── events
    │       └── file
    │           ├── dto
    │           ├── entities
    │           └── repositories
    ├── infrastructure
    │   ├── postgres
    │   │   └── typeorm
    │   │       ├── commands
    │   │       ├── migrations
    │   │       │   └── components
    │   │       ├── models
    │   │       ├── repository
    │   │       └── test
    │   ├── queue
    │   │   ├── bull
    │   │   └── rebbitMQ
    │   ├── redis
    │   │   └── repository
    │   └── s3
    │       └── miniO
    └── presentation
        └── nest
            ├── exceptionFilters
            ├── extends
            └── modules
                ├── auth
                │   ├── comands
                │   ├── controllers
                │   ├── dto
                │   ├── guards
                │   ├── repositories
                │   └── services
                ├── chat
                ├── events
                ├── file
                │   ├── controllers
                │   ├── repository
                │   └── services
                └── infrastructure

21 directories, 38 files


СОДЕРЖИМОЕ ФАЙЛОВ:
===================
================================================================
ФАЙЛ: ./project_analysis.txt
================================================================



================================================================
ФАЙЛ: ./infrastructure/queue/rebbitMQ/index.ts
================================================================
export const notImplemented = 'NOT_IMPLEMENTED';


================================================================
ФАЙЛ: ./infrastructure/queue/bull/index.ts
================================================================
export const notImplemented = 'NOT_IMPLEMENTED';


================================================================
ФАЙЛ: ./infrastructure/redis/repository/index.ts
================================================================
export * from "./entranceToken.repository";


================================================================
ФАЙЛ: ./infrastructure/redis/repository/entranceToken.repository.ts
================================================================
import { CreateEntranceTokenDto, EntranceToken, IEntranceTokenRepository } from "../../../core/domain/auth";
import { RedisAbstractConnection } from "../connection";
import { v4 } from "uuid";
import { IConfig } from "../../../core/application/config";
import { CommonError } from "../../../core/application/common/exceptions";



export abstract class EntranceTokenAbstractRepository  implements IEntranceTokenRepository {
    
    private readonly path : string = 'entrance';

    constructor (
        private readonly redis : RedisAbstractConnection,
        private readonly config: IConfig,
    ) {
    }
    
    async create (data : CreateEntranceTokenDto) : Promise<EntranceToken> {
        const redisClient = this.redis.getClient();
        const token : EntranceToken = {
            accountId: data.accountId,
            id : v4()
        }
        const tokenData = JSON.stringify(token);
        await redisClient.set(token.id+this.path, tokenData, "EX", this.config.serverConfig.entranceExpire);
        return token;
    }
    async getOrThrow(id : string) : Promise<EntranceToken> {
        const redisClient = this.redis.getClient();
        const tokenData = await redisClient.get(id+this.path);
        if (!tokenData) {
            CommonError.NotFound(`LINK NOT FOUND`);
        }
        return JSON.parse(tokenData);
    }
}


================================================================
ФАЙЛ: ./infrastructure/redis/connection.ts
================================================================
import { IConfig } from "../../core/application/config";
import Redis from "ioredis";




export abstract class RedisAbstractConnection {
    private readonly client: Redis;

    constructor(
        config: IConfig
    ) {
        this.client = this.createClient(config);
        this.client.on('connect', ()=> {
            console.log(`Redis подключен`);
        })
        this.client.on('error', (err) => {
            console.error('Ошибка подключения к Redis:', err);
        });
        this.client.on('end', () => {
            console.log('Соединение с Redis закрыто');
        });
    }

    private createClient(config: IConfig): Redis {
        const client: Redis = new Redis({
            host : config.redisConfig.host,
            port : config.redisConfig.port,
        });
        return client;
    }

    public getClient(): Redis {
       return this.client;
   }
}


================================================================
ФАЙЛ: ./infrastructure/redis/index.ts
================================================================
export * from "./connection";
export * from "./repository";


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/models/account.model.ts
================================================================
import { Account } from '../../../../core/domain/auth';
import { BaseEntity, Column, CreateDateColumn, Entity, PrimaryColumn, PrimaryGeneratedColumn } from 'typeorm';


interface creationData {
  login: string;
  password: string;
}

@Entity({ name: 'accounts'})
export class AccountModel extends BaseEntity implements Account  {
  
  constructor(data? : creationData) {
    super();
    if (data) {
      this.login = data.login;
      this.password = data.password;
    }
  }

  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({
    type: 'varchar',
    unique: true,
    nullable: false,
  })
  login: string;

  @Column({
    type: 'varchar',
    nullable: false,
  })
  password: string;

  @CreateDateColumn({
    name: 'created_at',
    type: 'timestamp',
    default: () => 'CURRENT_TIMESTAMP',
  })
  createdAt: Date;
}



================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/models/filePath.model.ts
================================================================
import { FilePath } from '../../../../core/domain/file';
import { BaseEntity, Column, CreateDateColumn, Entity, PrimaryColumn, PrimaryGeneratedColumn } from 'typeorm';


interface creationData {
    accountId: string;
    path: string;
    originalName: string;
    mimeType: string;
}

@Entity({ name: 'file-path'})
export class FilePathModel extends BaseEntity implements FilePath  {
  
  constructor(data? : creationData) {
    super();
    if (data) {
      this.accountId = data.accountId;
      this.path = data.path;
      this.mimeType = data.mimeType;
      this.originalName = data.originalName;
    }
  }

  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({
    type: "uuid",
    nullable: false,
  })
  accountId: string;

  @Column({
    type: 'varchar',
    nullable: false,
  })
  path: string;

  @Column({
    type: 'varchar',
    nullable: false,
  })
  originalName: string;
  
  @Column({
    type: 'varchar',
    nullable: false,
  })
  mimeType: string;


  @CreateDateColumn({
    name: 'created_at',
    type: 'timestamp',
    default: () => 'CURRENT_TIMESTAMP',
  })
  createdAt: Date;
}



================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/repository/account.repository.ts
================================================================
import { Account, IAccountRepository } from '../../../../core/domain/auth';
import { AccountModel } from '../models/account.model';

export abstract class AccountAbstractRepository implements IAccountRepository {
  async getById(id: string): Promise<Account | null> {
    return await AccountModel.findOne({where: {
      id: id
    }});
  }
  async getByLogin(login: string): Promise<Account | null> {
    return await AccountModel.findOne({where : {
        login: login
    }});
  }
}



================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/repository/index.ts
================================================================
export * from './account.repository';
export * from './filePath.repository';


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/repository/filePath.repository.ts
================================================================
import { CommonError } from "../../../../core/application";
import { CreateFilePathDto, FilePath, IFilePathRepository } from "../../../../core/domain/file";
import { FilePathModel } from "../models/filePath.model";


export abstract class FilePathAbstractRepository implements IFilePathRepository {
    
    async getByAccount(accountId: string): Promise<FilePath[]> {
        return await FilePathModel.find({where: {
            accountId: accountId
        }});
    }
    async getById(id: string): Promise<FilePath> {
        const filePath = await FilePathModel.findOne({
            where: {
                id: id
            }
        });
        if (!filePath) {
            CommonError.NotFound(`File not found`);
        }
        return filePath;
    }
    async create(data: CreateFilePathDto): Promise<FilePath> {
        const filePath = new FilePathModel({
            accountId: data.accountId,
            path: data.path,
            mimeType: data.mimeType,
            originalName: data.originalName
        });
        const createFilePath = await FilePathModel.save(filePath);
        return createFilePath;
    }

}


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/connection.ts
================================================================
import { DataSource } from "typeorm";
import { AppDataSource } from "./migrations/data-source";

export abstract class TypeOrmAbstractConnection {
    private readonly dataSource : DataSource;
    constructor (
    ) {
        this.dataSource = AppDataSource
    }

    public getClient() : DataSource {
        return this.dataSource;
    }
}


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/test/testConnection.ts
================================================================
import { DataSource } from "typeorm";
import { AccountModel } from "../models/account.model";
import * as dotenv from "dotenv";


export class TypeOrmTestConnection {
    private readonly dataSource: DataSource;

    constructor() {
        if (!process.env.CI) {
            dotenv.config({path: "./.env.test"});
        }
        this.dataSource = new DataSource({
            type: 'postgres',
            host: process.env.TEST_DB_HOST,
            port: Number(process.env.TEST_DB_PORT),
            username: process.env.TEST_DB_USERNAME,
            password: process.env.TEST_DB_PASSWORD,
            database: process.env.TEST_DATABASE,
            entities: [AccountModel],
            synchronize: true,
            dropSchema: true,
            logging: false,
            ssl: false,
            cache: false,
        });
    }
    public getClient(): DataSource {
        return this.dataSource;
    }
}


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/commands/registration.command.ts
================================================================
import { CommonError } from "../../../../core/application";
import { Account, CreateAccountDto, IRegistrationCommand } from "../../../../core/domain/auth";
import { AccountModel } from "../models/account.model";
import { TypeOrmAbstractConnection } from "../connection";


export abstract class RegistrationAbstractCommand implements IRegistrationCommand {

    constructor(
        private readonly typeOrmConnection: TypeOrmAbstractConnection
    ) {

    }

    async execute(dto: CreateAccountDto): Promise<Account> {
        const runner = this.typeOrmConnection.getClient().createQueryRunner();
        await runner.startTransaction();

        try {
            const candidate = await runner.manager.findOne(AccountModel, {where : {
                login: dto.login
            }});
            if(candidate) {
                CommonError.BadRequest('login used');
            }
            const account = new AccountModel({
                login: dto.login,
                password: dto.password
            });
             const savedAccount = await runner.manager.save(account);
             await runner.commitTransaction();
            return account;
        } catch (error) {
            await runner.rollbackTransaction();
            throw error;
        } finally {
            await runner.release();
        } 
    }

}


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/commands/index.ts
================================================================
export * from './registration.command';


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/index.ts
================================================================
export * from "./connection";
export * from "./repository";
export * from './commands';


================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/migrations/data-source.ts
================================================================
import { ConfigAbstractService } from '../../../../core/application/config';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import * as process from 'process';
import { DataSource } from 'typeorm';
import { init1759790518512 } from './components/1759790518512-init';

  dotenv.config();

class Config extends ConfigAbstractService {
    constructor() {
        super();
    }
}
const config = new Config();

export const AppDataSource = new DataSource({
    type: 'postgres',
    host: config.postgresConfig.host,
    port: config.postgresConfig.port,
    username: config.postgresConfig.username,
    password:  config.postgresConfig.password,
    database: config.postgresConfig.database,
    entities: [
        fs.existsSync(path.join(process.cwd(), 'dist'))
        ? path.join(process.cwd(), 'dist/src/**/*.model{.ts,.js}')
        : path.join(process.cwd(), 'src/**/*.model{.ts,.js}'),
    ],
  synchronize: false, 
  logging: false,
  ssl: false,
  cache: true,
  migrations: [
    init1759790518512
  ],
});



================================================================
ФАЙЛ: ./infrastructure/postgres/typeorm/migrations/components/1759790518512-init.ts
================================================================
import { MigrationInterface, QueryRunner } from "typeorm";

export class init1759790518512 implements MigrationInterface {

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "file-path" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "accountId" uuid NOT NULL, "path" character varying NOT NULL, "originalName" character varying NOT NULL, "mimeType" character varying NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "PK_4a31dbde0ae7f829e079bcfe523" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "accounts" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "login" character varying NOT NULL, "password" character varying NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), CONSTRAINT "UQ_2b995c673f59534efe164ced42d" UNIQUE ("login"), CONSTRAINT "PK_5a7a02c20412299d198e097a8fe" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "query-result-cache" ("id" SERIAL NOT NULL, "identifier" character varying, "time" bigint NOT NULL, "duration" integer NOT NULL, "query" text NOT NULL, "result" text NOT NULL, CONSTRAINT "PK_6a98f758d8bfd010e7e10ffd3d3" PRIMARY KEY ("id"))`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`DROP TABLE "query-result-cache"`);
        await queryRunner.query(`DROP TABLE "accounts"`);
        await queryRunner.query(`DROP TABLE "file-path"`);
    }

}



================================================================
ФАЙЛ: ./infrastructure/postgres/index.ts
================================================================
export * from './typeorm';


================================================================
ФАЙЛ: ./infrastructure/s3/miniO/index.ts
================================================================
export const notImplemented = 'NOT_IMPLEMENTED';


================================================================
ФАЙЛ: ./core/domain/file/dto/create.filePath.dto.ts
================================================================
export class CreateFilePathDto {
    accountId: string;
    path: string;
    originalName: string;
    mimeType: string;
}


================================================================
ФАЙЛ: ./core/domain/file/dto/index.ts
================================================================
export * from './create.filePath.dto';


================================================================
ФАЙЛ: ./core/domain/file/entities/filePath.core.ts
================================================================
export class FilePath {
    id: string;
    accountId: string;
    path: string;
    originalName: string;
    mimeType: string;

}


================================================================
ФАЙЛ: ./core/domain/file/entities/index.ts
================================================================
export * from './filePath.core';


================================================================
ФАЙЛ: ./core/domain/file/repositories/index.ts
================================================================
export * from './filePath.repository';


================================================================
ФАЙЛ: ./core/domain/file/repositories/filePath.repository.ts
================================================================
import { CreateFilePathDto } from "../dto";
import { FilePath } from "../entities/filePath.core";

export interface IFilePathRepository {
    getByAccount(account: string): Promise<FilePath[]>;
    getById(id: string): Promise<FilePath>;
    create(data: CreateFilePathDto): Promise<FilePath>;
}


================================================================
ФАЙЛ: ./core/domain/file/index.ts
================================================================
export * from './dto';
export * from './entities';
export * from './repositories';


================================================================
ФАЙЛ: ./core/domain/events/file.event.ts
================================================================
import { IEvent } from "./event";
import { EventType } from "./eventType.enum";

export class FileUploadedEvent implements IEvent {
  readonly type = EventType.file_upload;
  readonly timestamp = new Date();

  constructor(
    public readonly fileId: string,
    public readonly fileName: string,
    public readonly fileUrl: string,
    public readonly uploadedBy: string,
    public readonly accountId: string,
  ) {}
}


================================================================
ФАЙЛ: ./core/domain/events/chat.event.ts
================================================================
import { IEvent } from "./event";
import { EventType } from "./eventType.enum";

export class UserJoinedEvent implements IEvent {
  readonly type = EventType.join_chat;
  readonly timestamp = new Date();

  constructor(
    public readonly userId: string,
    public readonly username: string,
  ) {}
}

export class MessageSentEvent implements IEvent {
  readonly type = EventType.send_message;
  readonly timestamp = new Date();

  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly content: string,
  ) {}
}


================================================================
ФАЙЛ: ./core/domain/events/event.ts
================================================================
export interface IEvent {
  readonly type: string;
  readonly timestamp: Date;
}


================================================================
ФАЙЛ: ./core/domain/events/index.ts
================================================================
export * from './chat.event';
export * from './event';
export * from './file.event';
export * from './eventType.enum';


================================================================
ФАЙЛ: ./core/domain/events/eventType.enum.ts
================================================================
export enum EventType {
    join_chat = 'USER_JOIN_CHAT',
    file_upload = 'FILE_UPLOAD',
    send_message = 'SEND_MESSAGE'
}


================================================================
ФАЙЛ: ./core/domain/auth/dto/create.entranceToke.dto.ts
================================================================
export class CreateEntranceTokenDto {
    accountId: string;
}


================================================================
ФАЙЛ: ./core/domain/auth/dto/index.ts
================================================================
export * from './create.account.dto';
export * from './create.entranceToke.dto';


================================================================
ФАЙЛ: ./core/domain/auth/dto/create.account.dto.ts
================================================================
export class CreateAccountDto {
    login: string;
    password: string;
}


================================================================
ФАЙЛ: ./core/domain/auth/use-cases/registration.command.ts
================================================================
import { CreateAccountDto } from "../dto";
import { Account } from "../entities";

export interface IRegistrationCommand {
    execute(dto: CreateAccountDto): Promise<Account>;
}


================================================================
ФАЙЛ: ./core/domain/auth/use-cases/index.ts
================================================================
export * from './registration.command';


================================================================
ФАЙЛ: ./core/domain/auth/entities/refreshPayload.core.ts
================================================================
export class PayloadRefresh {
    sub: string;
}


================================================================
ФАЙЛ: ./core/domain/auth/entities/account.core.ts
================================================================
export class Account {
    id: string;
    login: string;
    password: string;
    createdAt: Date;
}


================================================================
ФАЙЛ: ./core/domain/auth/entities/entranceToken.core.ts
================================================================
export class EntranceToken {
    id: string;
    accountId: string;
}


================================================================
ФАЙЛ: ./core/domain/auth/entities/accessPayload.core.ts
================================================================
export class AccessPayload {
    sub: string;
    login: string;
}


================================================================
ФАЙЛ: ./core/domain/auth/entities/index.ts
================================================================
export * from './accessPayload.core';
export * from './account.core';
export * from './refreshPayload.core'
export * from './entranceToken.core';


================================================================
ФАЙЛ: ./core/domain/auth/repositories/account.repository.ts
================================================================
import { Account } from "../entities";

export interface IAccountRepository {
    getById (id: string): Promise<Account | null>;
    getByLogin(login: string): Promise<Account | null>;
}


================================================================
ФАЙЛ: ./core/domain/auth/repositories/index.ts
================================================================
export * from './account.repository';
export * from './entranceToken.repository';


================================================================
ФАЙЛ: ./core/domain/auth/repositories/entranceToken.repository.ts
================================================================
import { CreateEntranceTokenDto } from "../dto";
import { EntranceToken } from "../entities";

export interface IEntranceTokenRepository {
    getOrThrow(id: string): Promise<EntranceToken>;
    create(dto: CreateEntranceTokenDto): Promise<EntranceToken>;
}


================================================================
ФАЙЛ: ./core/domain/auth/index.ts
================================================================
export * from './dto';
export * from './entities';
export * from './repositories';
export * from './use-cases';


================================================================
ФАЙЛ: ./core/application/dto/request/registration.dto.ts
================================================================
export class RegistrationDto {
    login: string;
    password: string;
}


================================================================
ФАЙЛ: ./core/application/dto/request/login.dto.ts
================================================================
export class LoginDto {
    login: string;
    password: string;
}


================================================================
ФАЙЛ: ./core/application/dto/request/file.dto.ts
================================================================
export class FileDto {
    originalName: string;
    buffer: Buffer;
    mimetype: string;
    size: number;
    accountId: string;
}


================================================================
ФАЙЛ: ./core/application/dto/request/index.ts
================================================================
export * from './login.dto';
export * from './registration.dto';


================================================================
ФАЙЛ: ./core/application/dto/response/file.response.ts
================================================================
import { FilePath } from "../../../../core/domain/file"

export class FileResponse {
    filePath: FilePath;
    stream: NodeJS.ReadableStream;
}


================================================================
ФАЙЛ: ./core/application/dto/response/auth.response.ts
================================================================
import { AccountResponse } from "./account.response";
import { TokenResponse } from "./token.response";

export class AuthResponse {
    tokenResponse: TokenResponse;
    accountResponse: AccountResponse;
}


================================================================
ФАЙЛ: ./core/application/dto/response/token.response.ts
================================================================
export class TokenResponse {
    access:string;
    refresh:string;
}


================================================================
ФАЙЛ: ./core/application/dto/response/account.response.ts
================================================================
export class AccountResponse {
    login: string;
}


================================================================
ФАЙЛ: ./core/application/dto/response/index.ts
================================================================
export * from './account.response';
export * from './auth.response';
export * from './token.response';
export * from './file.response';


================================================================
ФАЙЛ: ./core/application/dto/index.ts
================================================================
export * from './request';
export * from './response';


================================================================
ФАЙЛ: ./core/application/services/fileStorage.service.ts
================================================================
import { Injectable } from '@nestjs/common';
import { IFileStorageService } from '../interfaces';
import { v4 } from 'uuid';
import { FileDto } from '../dto/request/file.dto';
import { extname } from 'path';
import * as fs from 'fs';
import { IConfig } from '../config';
import { FilePath } from '../../../core/domain/file';
import { CommonError } from '../common';

@Injectable()
export abstract class LocalStorageAbstractService implements IFileStorageService {
  
    private path : string;

    constructor(
        private readonly config: IConfig
    ) {
        this.path =  config.fileStorageConfig.pathToStorage;
    }

    async getFileStream(filePath: FilePath): Promise<NodeJS.ReadableStream> {
        if (!fs.existsSync(filePath.path)) {
            CommonError.NotFound('File not found');
        }
        return fs.createReadStream(filePath.path);
    }

    async saveFile(file: FileDto): Promise<string> {
        const fileExtension = extname(file.originalName);
        const uniqueFilename = `${v4()}${fileExtension}`;
        const filePath = `uploads/${file.accountId}/${uniqueFilename}`;
        fs.mkdirSync(`uploads/${file.accountId}`, { recursive: true });
        fs.writeFileSync(filePath, file.buffer);
        return filePath;
    }

}


================================================================
ФАЙЛ: ./core/application/services/jwt.service.ts
================================================================
import { AccessPayload, PayloadRefresh } from "../../../core/domain/auth";
import { TokenResponse } from "../dto";
import { IJwtService } from "../interfaces";
import { sign, verify } from 'jsonwebtoken';
import { IConfig } from "../config";
import { CommonError } from "../common/exceptions";

export abstract class JwtAbstractService implements IJwtService {
  private readonly accessSecretKey : string;
  private readonly refreshSecretKey : string;
  private readonly accessExpire : number;
  private readonly refreshExpire : number;

  constructor (
    config : IConfig
  ) {
    this.accessSecretKey = config.authConfig.accSecret;
    this.refreshSecretKey = config.authConfig.refSecret;
    this.accessExpire = config.authConfig.accessExpire;
    this.refreshExpire = config.authConfig.refreshExpire;
  }

  sign(accessPayload:AccessPayload,refreshPayload: PayloadRefresh): TokenResponse {
    const accessToken = sign(accessPayload, this.accessSecretKey, {
      expiresIn: this.accessExpire,
    });
    const refreshToken = sign(refreshPayload, this.refreshSecretKey, {
      expiresIn: this.refreshExpire,
    });
    return { access: accessToken, refresh: refreshToken };
  }

  verifyRefresh(token: string): PayloadRefresh {
    try {
      const tokenData = verify(token, this.refreshSecretKey);
      const payload: PayloadRefresh = tokenData as PayloadRefresh;
      return payload;
    } catch (error) {
      throw CommonError.Unauthorized('Invalid token');
    }
  }

  verifyAccess(token: string): AccessPayload {
    try {
      const tokenData = verify(token, this.accessSecretKey);
      const payload: AccessPayload = tokenData as AccessPayload;
      return payload;
    } catch (error) {
      CommonError.Unauthorized('Invalid token');
    }
  }
}


================================================================
ФАЙЛ: ./core/application/services/auth.service.ts
================================================================
import { AccessPayload, EntranceToken, IAccountRepository, IEntranceTokenRepository, IRegistrationCommand } from "../../domain/auth";
import { AuthResponse, LoginDto, RegistrationDto, TokenResponse } from "../dto";
import { IAuthService, ICryptoService, IJwtService } from "../interfaces";
import { CommonError } from "../common/exceptions";

export abstract class AuthAbstractService implements IAuthService {
    
    constructor(
        private readonly  registrationCommand: IRegistrationCommand,
        private readonly accountRepository: IAccountRepository,
        private readonly cryptoService: ICryptoService,
        private readonly jwtService: IJwtService,
        private readonly entranceTokenRepository: IEntranceTokenRepository
    ) {

    }
    validateAccess(token: string): AccessPayload {
        return  this.jwtService.verifyAccess(token);
    }
    async refresh(token: string): Promise<TokenResponse> {
        const refreshPayload = this.jwtService.verifyRefresh(token);
        const account = await this.accountRepository.getById(refreshPayload.sub);
        if (!account) {
            CommonError.BadRequest('Account is not exist');
        }
        return this.jwtService.sign({
            login: account.login, 
            sub: account.id
        }, {
            sub: account.id
        });
    }

    async registration(data: RegistrationDto) : Promise<AuthResponse> {
        const hashedPassword = await this.cryptoService.hashPassword(data.password);
        const account = await this.registrationCommand.execute({
            login: data.login,
            password: hashedPassword,
        });
        const tokens = this.jwtService.sign({
            login: account.login,
            sub: account.id
        }, {
            sub: account.id
        });

        return {
            accountResponse: {
                login: account.login
            },
            tokenResponse: {
                access: tokens.access,
                refresh: tokens.refresh
            }
        }
    }
    
    async login(data: LoginDto) : Promise<AuthResponse> {
        const account = await this.accountRepository.getByLogin(data.login);
        if (!account) {
            CommonError.BadRequest('wrong login or password');
        }
        const comparedPassword = await this.cryptoService.comparePassword(data.password, account.password);
        if (!comparedPassword) {
            CommonError.BadRequest('wrong login or password');
        }
        const tokens = this.jwtService.sign({
            login: account.login,
            sub: account.id
        }, {
            sub: account.id
        });
        return {
            accountResponse: {
                login: account.login
            },
            tokenResponse: {
                access: tokens.access,
                refresh: tokens.refresh
            }
        }
    }

    async createEntranceToken (accountId: string): Promise<EntranceToken> {
        const token = await this.entranceTokenRepository.create({
            accountId: accountId
        });
        return token;
    }
    async loginWithEntranceToken(tokenId: string): Promise<AuthResponse> {
        const token = await this.entranceTokenRepository.getOrThrow(tokenId);
        const account = await this.accountRepository.getById(token.accountId);
        if (!account) {
            CommonError.BadRequest('Account is not exist');            
        }
        const tokens = this.jwtService.sign({
            login: account.login,
            sub: account.id
        }, {
            sub: account.id
        });
        return {
            accountResponse: {
                login: account.login
            },
            tokenResponse: {
                access: tokens.access,
                refresh: tokens.refresh
            }
        }
    }
}


================================================================
ФАЙЛ: ./core/application/services/index.ts
================================================================
export * from './auth.service';
export * from './crypto.service';
export * from './file.service';
export * from './jwt.service';
export * from './fileStorage.service';


================================================================
ФАЙЛ: ./core/application/services/crypto.service.ts
================================================================
import { ICryptoService } from "../interfaces";
import { compare, hash } from 'bcrypt';

export abstract class CryptoAbstractService implements ICryptoService  {
  async hashPassword(pass: string): Promise<string> {
    return await hash(pass, 10);
  }
  async comparePassword(pass: string, hash: string): Promise<boolean> {
    return await compare(pass, hash);
  }
}



================================================================
ФАЙЛ: ./core/application/services/file.service.ts
================================================================
import { FilePath, IFilePathRepository } from "../../../core/domain/file";
import { IFileService, IFileStorageService } from "../interfaces";
import { FileDto } from "../dto/request/file.dto";
import { FileResponse } from "../dto";
import { EventBus } from "../common/events";
import { FileUploadedEvent } from "../../../core/domain/events/file.event";


export abstract class FileAbstractService implements IFileService {
    
    constructor (
        private readonly fileStorageService: IFileStorageService,
        private readonly filePathRepository: IFilePathRepository,
        private readonly eventBus: EventBus,
    ) {
    }
    
    
    async getFile(fileId: string): Promise<FileResponse> {
       const filePath = await this.filePathRepository.getById(fileId);
       const stream = await this.fileStorageService.getFileStream(filePath);
       return {
        filePath: filePath,
        stream: stream,
       }
    }

    async saveFile(data: FileDto): Promise<FilePath> {
        const path =await this.fileStorageService.saveFile(data);
        const filePath = await this.filePathRepository.create({
            accountId: data.accountId,
            mimeType: data.mimetype,
            originalName: data.originalName,
            path: path
        });
        this.eventBus.publish(new FileUploadedEvent(
            filePath.id,
            filePath.originalName,
            `/api/files/download/${filePath.id}`,
            data.accountId,
            data.accountId
        ));
        return filePath;
    }
    
    async getByAccount(accountId: string): Promise<FilePath[]> {
        return await this.filePathRepository.getByAccount(accountId);
    }
    
    async getById(id: string): Promise<FilePath> {
        return await this.filePathRepository.getById(id);
    }
}


================================================================
ФАЙЛ: ./core/application/common/exceptions/dateParser.ts
================================================================
export class DateParser {
  static getSeconds(): number {
    const date = Math.floor(Date.now() / 1000);
    return date;
  }

  static getCurrentDateTime(): string {
    const date = new Date();

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  }
}



================================================================
ФАЙЛ: ./core/application/common/exceptions/http.error.ts
================================================================
import { CommonError, ErrorType } from "./common.error";

export class HttpError extends CommonError {

  status: number;
  constructor(err: CommonError) {
    super(err.type, err.message, err.errors);
    switch(err.type) {
      case ErrorType.badRequest : {
        this.status = 400;
        break;
      }
      case ErrorType.internal: {
        this.status = 500;
        break;
      }
      case ErrorType.noAccess: {
        this.status = 403;
        break;
      }
      case ErrorType.notFound: {
        this.status = 404;
        break;
      }
      case ErrorType.rateLimit: {
        this.status = 429;
        break;
      }
      case ErrorType.unknown: {
        this.status = 500;
        break;
      }
      case ErrorType.unauthorized: {
        this.status = 401;
        break;
      }
    }
  }
}



================================================================
ФАЙЛ: ./core/application/common/exceptions/error.any.type.ts
================================================================
export type ErrorAny = unknown;


================================================================
ФАЙЛ: ./core/application/common/exceptions/common.error.ts
================================================================
import { DateParser } from "./dateParser";
import { ErrorAny } from "./error.any.type";

export enum ErrorType {
  unauthorized = 'UNAUTHORIZED_ERROR',
  badRequest = 'BAD_REQUEST_ERROR',
  internal = 'INTERNAL_ERROR',
  noAccess = 'NO_ACCESS_ERROR',
  notFound = 'NOT_FOUND',
  rateLimit = 'RATE_LIMIT',
  unknown = 'UNKNOWN_ERROR',
  lostConnection = 'LOST_CONNECTION',
}

export class CommonError extends Error {
  public errors: ErrorAny[];
  public type: ErrorType;
  constructor(type: ErrorType, message?: string, errors?: ErrorAny[] | ErrorAny) {
    if (!type) {
      type = ErrorType.unknown;
    }
    super(message + `\n${DateParser.getCurrentDateTime()}`);
    if (errors) {
      this.errors = Array.isArray(errors) ? errors : [errors];
    } else {
      this.errors = [];
    }
    this.type = type;
  }

  static Unauthorized(message?: string): never {
    let mess: string = ' ';
    if (!message) {
      mess = 'Unathorized error';
    } else {
      mess = message;
    }
    throw new CommonError(ErrorType.unauthorized, mess);
  }

  static BadRequest(message?: string, errors?: ErrorAny[]): never {
    throw new CommonError(ErrorType.badRequest, message, errors);
  }

  static InternalError(message?: string, errors?: ErrorAny[]): never {
    throw new CommonError(
      ErrorType.internal,
      'Internal Server Error\n ' + message,
      errors,
    );
  }

  static Forbidden(errors?: ErrorAny[]): never {
    throw new CommonError(ErrorType.noAccess, 'No access', errors);
  }

  static NotFound(message?: string, errors?: ErrorAny[]): never {
    let mess: string = ' ';
    if (!message) {
      mess = 'Not found';
    } else {
      mess = message;
    }
    throw new CommonError(ErrorType.notFound, mess, errors);
  }

  static RateLimitExecced(message?: string, errors?: ErrorAny[]): never {
    let mess: string = ' ';
    if (!message) {
      mess = 'Too many requests';
    } else {
      mess = message;
    }
    throw new CommonError(ErrorType.rateLimit, mess, errors);
  }

  static ConnectionLost(message?: string, errors?: ErrorAny[]): never {
    let mess: string = ' ';
    if (!message) {
      mess = `Connection lost`;
    } else {
      mess = message;
    }
    throw new CommonError(ErrorType.rateLimit, mess, errors);
  }
}




================================================================
ФАЙЛ: ./core/application/common/exceptions/index.ts
================================================================
export * from './common.error';
export * from "./dateParser";
export * from "./http.error";
export * from "./error.any.type";


================================================================
ФАЙЛ: ./core/application/common/index.ts
================================================================
export * from './exceptions';


================================================================
ФАЙЛ: ./core/application/common/events/event.bus.ts
================================================================
import { IEvent } from "../../../../core/domain/events/event";

export abstract class EventBus {
  abstract publish<T extends IEvent>(event: T): void;
  abstract subscribe<T extends IEvent>(eventType: string, handler: EventHandler<T>): void;
}



export type EventHandler<T extends IEvent> = (event: T) => void;


================================================================
ФАЙЛ: ./core/application/common/events/index.ts
================================================================
export * from './event.bus';


================================================================
ФАЙЛ: ./core/application/interfaces/fileStorage.service.ts
================================================================
import { FilePath } from "../../../core/domain/file";
import { FileDto } from "../dto/request/file.dto";

export interface IFileStorageService {
    saveFile(data: FileDto) : Promise<string>;
    getFileStream(fileRecord: FilePath): Promise<NodeJS.ReadableStream>
}


================================================================
ФАЙЛ: ./core/application/interfaces/jwt.service.ts
================================================================
import { AccessPayload, PayloadRefresh } from "../../../core/domain/auth";
import { TokenResponse } from "../dto";

export interface IJwtService {
    sign(accessPayload: AccessPayload, refreshPayload: PayloadRefresh): TokenResponse; 
    verifyAccess(token: string): AccessPayload;
    verifyRefresh(token: string): PayloadRefresh;
}


================================================================
ФАЙЛ: ./core/application/interfaces/auth.service.ts
================================================================
import { AccessPayload, EntranceToken } from "../../domain/auth";
import { AuthResponse, LoginDto, RegistrationDto, TokenResponse } from "../dto";

export interface IAuthService {
    registration(data: RegistrationDto) : Promise<AuthResponse>;
    login(data: LoginDto) : Promise<AuthResponse>;
    createEntranceToken (accountId: string): Promise<EntranceToken>;
    loginWithEntranceToken(token: string): Promise<AuthResponse>;    
    refresh(token: string): Promise<TokenResponse>;   
    validateAccess(token: string): AccessPayload;
}


================================================================
ФАЙЛ: ./core/application/interfaces/index.ts
================================================================
export * from './auth.service';
export * from './file.service';
export * from './crypto.service';
export * from './jwt.service';
export * from './fileStorage.service';


================================================================
ФАЙЛ: ./core/application/interfaces/crypto.service.ts
================================================================
export interface  ICryptoService  {
  hashPassword(pass: string): Promise<string>;
  comparePassword(pass: string, hash: string): Promise<boolean>;
}



================================================================
ФАЙЛ: ./core/application/interfaces/file.service.ts
================================================================
import { FilePath } from "../../../core/domain/file";
import { FileDto } from "../dto/request/file.dto";
import { FileResponse } from "../dto";

export interface IFileService {
    saveFile(data: FileDto): Promise<FilePath>;
    getByAccount(accountId: string): Promise<FilePath[]>;
    getById(id: string): Promise<FilePath>;
    getFile(id: string): Promise<FileResponse>
}


================================================================
ФАЙЛ: ./core/application/index.ts
================================================================
export * from './common';
export * from './config'
export * from './dto';
export * from './interfaces';
export * from './services';


================================================================
ФАЙЛ: ./core/application/config/postgres.config.ts
================================================================
export interface IPostgresConfig {
  username: string;
  password: string;
  host: string;
  port: number;
  database: string;
}

export class PostgresConfig implements IPostgresConfig {
  username: string;
  password: string;
  host: string;
  port: number;
  database: string;
  constructor() {
    this.username = process.env.DATABASE_USER || 'postgres';
    this.password = process.env.DATABASE_PASSWORD || 'root';
    this.host = process.env.DATABASE_HOST || 'localhost';
    this.port = Number(process.env.DATABASE_PORT) || 5432;
    this.database = process.env.DATABASE_NAME || 'default';
  }
}



================================================================
ФАЙЛ: ./core/application/config/auth.config.ts
================================================================
export interface IAuthConfig {
  accSecret: string;
  refSecret: string;
  accessExpire : number;
  refreshExpire : number;
}

export class AuthConfig implements IAuthConfig {
  accSecret: string;
  refSecret: string;
  accessExpire : number;
  refreshExpire : number;
  constructor() {
    this.accSecret = process.env.ACCESS_SECRET || 'access';
    this.refSecret = process.env.REFRESH_SECRET || 'secret';
    this.accessExpire = Number(process.env.ACCESS_EXPIRE) || 60 * 1000;
    this.refreshExpire = Number(process.env.REFRESH_EXPIRE) || 60 * 24 * 60 * 60 * 1000;
  }
}



================================================================
ФАЙЛ: ./core/application/config/redis.config.ts
================================================================
export interface IRedisConfig {
    host: string;
    port: number;
}

export class RedisConfig implements IRedisConfig {
    host: string;
    port: number;
    constructor() {
        this.port = Number(process.env.REDIS_PORT) || 5656;
        this.host = process.env.REDIS_HOST || 'localhost'
    }
}


================================================================
ФАЙЛ: ./core/application/config/server.config.ts
================================================================
export interface IServerConfig {
  port: number;
  entranceExpire: number;
}
export class ServerConfig implements IServerConfig {
  port: number;
  entranceExpire: number;
  constructor() {
    this.port = Number(process.env.PORT) || 3002;
    this.entranceExpire =Number(process.env.ENTRANCE_EXPIRE);
  }
}



================================================================
ФАЙЛ: ./core/application/config/fileStorage.config.ts
================================================================
export interface IFileStorageConfig {
    pathToStorage: string;
}

export class FileStorageConfig implements IFileStorageConfig {
    pathToStorage: string;
    constructor() {
        this.pathToStorage = process.env.PATH_TO_STORAGE || 'localhost:3003/api/files/download/';
    }
}


================================================================
ФАЙЛ: ./core/application/config/index.ts
================================================================
import * as dotenv from 'dotenv';
import { AuthConfig, IAuthConfig } from './auth.config';
import { IPostgresConfig, PostgresConfig } from './postgres.config';
import { IRedisConfig, RedisConfig } from './redis.config';
import { IServerConfig, ServerConfig } from './server.config';
import { FileStorageConfig, IFileStorageConfig } from './fileStorage.config';


dotenv.config();



export interface IConfig {
  authConfig: IAuthConfig;
  postgresConfig: IPostgresConfig;
  serverConfig: IServerConfig;
  redisConfig: IRedisConfig;
  fileStorageConfig: IFileStorageConfig;
}

export abstract class ConfigAbstractService implements IConfig {
  authConfig: IAuthConfig;
  postgresConfig: IPostgresConfig;
  serverConfig: IServerConfig;
  redisConfig: IRedisConfig;
  fileStorageConfig: IFileStorageConfig;
  constructor() {
    this.authConfig = new AuthConfig();
    this.postgresConfig = new PostgresConfig();
    this.serverConfig = new ServerConfig();
    this.redisConfig = new RedisConfig();
    this.fileStorageConfig = new FileStorageConfig();
  }
}



================================================================
ФАЙЛ: ./presentation/nest/extends/extend.request.ts
================================================================
import { Request } from 'express';

export interface AccountDto {
  id: string;
  login: string;
}

export interface ExtendRequest extends Request {
  account: AccountDto;
}



================================================================
ФАЙЛ: ./presentation/nest/bootstrap.ts
================================================================
import { NestFactory } from '@nestjs/core';

import { CommonErrorFilter } from './exceptionFilters/Http.filter'; 
import { AppModule, INFRASTRUCTURE_CONSTANTS } from './modules';
import { ConfigAbstractService } from '../../core/application';
import { TypeOrmAbstractConnection } from '../../infrastructure/postgres';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

export async function start(): Promise<void> {
  const app = await NestFactory.create(AppModule);
  const config = app.get<ConfigAbstractService>(INFRASTRUCTURE_CONSTANTS.CONFIG);
  const pg = app.get<TypeOrmAbstractConnection>(INFRASTRUCTURE_CONSTANTS.PG);
  await pg.getClient().initialize();
    
  const swaggerConfig = new DocumentBuilder()
    .setTitle('File Storage API')
    .setDescription('API for file upload and download with authentication')
    .setVersion('1.0')
    .addBearerAuth(
      {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        name: 'JWT',
        description: 'Enter JWT token',
        in: 'header',
      },
      'JWT-auth',
    )
    .addTag('auth', 'Authentication endpoints')
    .addTag('files', 'File management endpoints')
    .build();

  const document = SwaggerModule.createDocument(app, swaggerConfig);
  SwaggerModule.setup('api/docs', app, document, {
    swaggerOptions: {
      persistAuthorization: true,
    },
  });

    app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
    disableErrorMessages: false,
  }));
  app.enableCors({
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    allowedHeaders: 'Content-Type, Accept, Authorization',
    credentials: true,
  });
  app.useGlobalFilters(new CommonErrorFilter());
  await app.listen(config.serverConfig.port);
}



================================================================
ФАЙЛ: ./presentation/nest/exceptionFilters/Http.filter.ts
================================================================
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { CommonError, ErrorAny, HttpError } from '../../../core/application/common/exceptions';
import { Response } from 'express';

interface ErrorBody {
  message: string;
  errors?: ErrorAny | ErrorAny[];
  statusCode?: number;
}

@Catch(CommonError, HttpException)
export class CommonErrorFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    
    if (exception instanceof CommonError) {
      const httpError = new HttpError(exception);
      const errors = exception.errors as ErrorAny[];
      const responseBody: ErrorBody = {
        message: exception.message,
        errors,
        statusCode: httpError.status,
      };
      response.status(httpError.status).json(responseBody);
      return;
    }

    if (exception instanceof HttpException) {
      const status = exception.getStatus();
      const responseData = exception.getResponse();
      let message: string;
      let errors: ErrorAny[] = [];
      if (typeof responseData === 'string') {
        message = responseData;
      } else {
        message = responseData['message'] || 'Unknown error';
        errors = responseData['errors'] || [];
      }
      if (exception.cause && !errors.length) {
        errors = [exception.cause as ErrorAny];
      }

      const responseBody: ErrorBody = {
        message,
        errors: errors.length ? errors : undefined,
        statusCode: status,
      };

      response.status(status).json(responseBody);
      return ;
    }

    const responseBody: ErrorBody = {
      message: 'Internal Server Error',
      statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
    };

    response.status(HttpStatus.INTERNAL_SERVER_ERROR).json(responseBody);
  }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/file/repository/index.ts
================================================================
export * from './filePath.repository';


================================================================
ФАЙЛ: ./presentation/nest/modules/file/repository/filePath.repository.ts
================================================================
import { Injectable } from "@nestjs/common";
import { FilePathAbstractRepository } from "../../../../../infrastructure/postgres";

@Injectable()
export class FilePathRepository extends FilePathAbstractRepository {
    constructor() {
        super();
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/file/file.module.ts
================================================================
import { Module } from "@nestjs/common";
import { InfrastructureModule } from "../infrastructure";
import { AuthModule } from "../auth/auth.module";
import { FILE_CONSTANTS } from "../constants";
import { FilePathRepository } from "./repository";
import { FileController } from "./controllers";
import { FileService } from "./services/file.service";
import { FileStorageService } from "./services/fileStorage.service";
import { EventModule } from "../events/event.module";

@Module({
    imports: [
        InfrastructureModule,
        AuthModule,
        EventModule
    ],
    controllers: [
        FileController
    ],
    providers: [
        {provide: FILE_CONSTANTS.FILE_PATH_REPOSITORY, useClass: FilePathRepository},
        {provide: FILE_CONSTANTS.FILE_SERVICE, useClass: FileService},
        {provide: FILE_CONSTANTS.FILE_STORAGE_SERVICE, useClass: FileStorageService},
    ]
})
export class FileModule {
    
}


================================================================
ФАЙЛ: ./presentation/nest/modules/file/services/fileStorage.service.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { IConfig, LocalStorageAbstractService } from "../../../../../core/application";
import { INFRASTRUCTURE_CONSTANTS } from "../../constants";

@Injectable()
export class FileStorageService extends LocalStorageAbstractService {
    constructor(
        @Inject(INFRASTRUCTURE_CONSTANTS.CONFIG) config: IConfig
    ) {
        super(config);
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/file/services/file.service.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { FileAbstractService, IFileStorageService } from "../../../../../core/application";
import { EVENT_CONSTANTS, FILE_CONSTANTS } from "../../constants";
import { IFilePathRepository } from "../../../../../core/domain/file";
import { NestEventBus } from "../../events/event.bus";

@Injectable()
export class FileService extends FileAbstractService {
    constructor(
        @Inject(FILE_CONSTANTS.FILE_PATH_REPOSITORY) filePathRepository: IFilePathRepository,
        @Inject(FILE_CONSTANTS.FILE_STORAGE_SERVICE) fileStorageService: IFileStorageService,
        @Inject(EVENT_CONSTANTS.EVENT_BUS) eventBus: NestEventBus
    ) {
        super(
            fileStorageService,
            filePathRepository,
            eventBus,
        );
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/file/controllers/file.controller.ts
================================================================
import { Controller, Post, UseInterceptors, UploadedFile, Body, UseGuards, Inject, Get, Param, Res, Req, ParseUUIDPipe } from "@nestjs/common";
import { FileInterceptor } from "@nestjs/platform-express";
import { AuthGuard } from "../../auth/guards";
import { ExtendRequest } from "../../../extends/extend.request";
import { Response } from "express";
import { FILE_CONSTANTS } from "../../constants";
import { IFileService } from "../../../../../core/application";
import { FilePath } from "../../../../../core/domain/file";
import { ApiBearerAuth, ApiBody, ApiConsumes, ApiParam, ApiResponse, ApiTags } from "@nestjs/swagger";

@ApiTags('files')
@Controller('files')
export class FileController {
  constructor(
    @Inject(FILE_CONSTANTS.FILE_SERVICE) 
    private readonly fileService: IFileService,
  ) {}


  @Post('upload')
  @UseGuards(AuthGuard)
  @ApiBearerAuth('JWT-auth')
  @UseInterceptors(FileInterceptor('file'))
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
          description: 'File to upload'
        },
      },
    },
  })
  @ApiResponse({ status: 201, type: String})
  async uploadFile(
    @UploadedFile() file: Express.Multer.File,
    @Req() req: ExtendRequest,
  ): Promise<string> {
    const accountId = req.account.id;
    const fileData = {
      accountId,
      originalName: file.originalname,
      buffer: file.buffer,
      mimetype: file.mimetype,
      size: file.size
    };
    const savedFile = await this.fileService.saveFile(fileData);
    return savedFile.id;
  }

  @Get()
   @ApiBearerAuth('JWT-auth')
   @ApiResponse({ status: 200,  type: [String] })
  @UseGuards(AuthGuard)
  async getFiles(@Req() req: ExtendRequest): Promise<string[]> {
    const accountId = req.account.id;
    const filePaths = await this.fileService.getByAccount(accountId);
    return filePaths.map(fp=>fp.path);
  }

  @Get(':id')
  @UseGuards(AuthGuard)
  @ApiBearerAuth('JWT-auth')
  @ApiParam({ name: 'id',  type: String, })
  async getFile(@Param('id', ParseUUIDPipe) id: string, @Req() req: ExtendRequest): Promise<FilePath> {
    const accountId = req.account.id;
    const file = await this.fileService.getById(id);    
    return file;
  }

  @Get('download/:fileId')
  @UseGuards(AuthGuard)
  @ApiBearerAuth('JWT-auth')
  @ApiParam({ name: 'fileId', type: String, })
  @ApiResponse({ 
    status: 200, 
    description: 'File download',
    content: {
      'application/octet-stream': {
        schema: {
          type: 'string',
          format: 'binary'
        }
      }
    }
  })
  async downloadFile(
    @Param('fileId', ParseUUIDPipe) fileId: string,
    @Res() res: Response,
  ): Promise<void> {
    const file = await this.fileService.getFile(fileId);
    res.setHeader('Content-Type', file.filePath.mimeType);
    res.setHeader('Content-Disposition', `attachment; filename="${file.filePath.originalName}"`);
    file.stream.pipe(res);
  }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/file/controllers/index.ts
================================================================
export * from './file.controller';


================================================================
ФАЙЛ: ./presentation/nest/modules/file/index.ts
================================================================
export * from './file.module';


================================================================
ФАЙЛ: ./presentation/nest/modules/app.module.ts
================================================================
import { Module } from "@nestjs/common";
import { AuthModule } from "./auth";
import { InfrastructureModule } from "./infrastructure";
import { FileModule } from "./file";
import { EventModule } from "./events/event.module";



@Module({
    imports: [InfrastructureModule, AuthModule, FileModule, EventModule]
})
export class AppModule {}


================================================================
ФАЙЛ: ./presentation/nest/modules/chat/chat.service.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { EventBus } from "../../../../core/application/common/events";
import { FileUploadedEvent, UserJoinedEvent, MessageSentEvent, EventType} from "../../../../core/domain/events/";
import { EVENT_CONSTANTS } from "../constants";
import { Server } from 'socket.io';
import { WebSocketServer } from "@nestjs/websockets";

@Injectable()
export class ChatService {
  
  @WebSocketServer()
  private server: Server;

  constructor(
    @Inject(EVENT_CONSTANTS.EVENT_BUS) private readonly eventBus: EventBus
) {
    this.eventBus.subscribe(EventType.file_upload, this.handleFileUploaded.bind(this));
    this.eventBus.subscribe(EventType.join_chat, this.handleUserJoined.bind(this));
    this.eventBus.subscribe(EventType.send_message, this.handleUserMessage.bind(this));
  }

  private handleFileUploaded(event: FileUploadedEvent): void {
    this.broadcastToAll('file_uploaded', {
      fileUrl: event.fileUrl,
      fileName: event.fileName,
      uploadedBy: event.uploadedBy,
      timestamp: event.timestamp
    });
  }

  private handleUserJoined(event: UserJoinedEvent): void {
    this.broadcastToAll('user_joined', {
      username: event.username,
      message: `${event.username} вошел в чат`,
      timestamp: event.timestamp
    });
  }

  private handleUserMessage(event: MessageSentEvent): void {
    this.broadcastToAll('send_message', {
      username: event.username,
      message: event.content,
      timestamp: event.timestamp
    });
  }

  private broadcastToAll(event: string, data: any): void {
    this.server.emit(event, data);
  }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/chat/chat.module.ts
================================================================
import { Module } from "@nestjs/common";
import { EventModule } from "../events/event.module";
import { AuthModule } from "../auth";
import { CHAT_CONSTANTS } from "../constants";
import { ChatService } from "./chat.service";
import { ChatGateway } from "./chat.gateway";


@Module({
    imports: [EventModule, AuthModule],
    providers: [
        {provide: CHAT_CONSTANTS.CHAT_SERVICE, useClass: ChatService},
        {provide: CHAT_CONSTANTS.CHAT_GATEWAY, useClass: ChatGateway}
    ],
    exports : [
        CHAT_CONSTANTS.CHAT_SERVICE
    ]
})
export class ChatModule {}


================================================================
ФАЙЛ: ./presentation/nest/modules/chat/chat.gateway.ts
================================================================
import { OnGatewayConnection, OnGatewayDisconnect, SubscribeMessage, WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import { MessageSentEvent, UserJoinedEvent } from "../../../../core/domain/events";
import { NestEventBus } from "../events/event.bus";
import { Server, Socket } from "socket.io";
import { AUTH_CONSTANTS, EVENT_CONSTANTS } from "../constants";
import { Inject } from "@nestjs/common";
import { IAuthService } from "../../../../core/application";

interface AuthenticatedSocket extends Socket {
  user: {
    id: string;
    login: string;
  };
}


@WebSocketGateway({
    cors: {
        origin: "*",
        credentials: true,
    }
}
)
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
  
    @WebSocketServer()
    private server: Server;
    private connectedUsers = new Map<string, { id: string; login: string; socketId: string }>();

    constructor(
        @Inject(EVENT_CONSTANTS.EVENT_BUS) private readonly eventBus: NestEventBus,
        @Inject(AUTH_CONSTANTS.AUTH_SERVICE) 
            private readonly authService: IAuthService
    ) {

    }

    async handleConnection(client: AuthenticatedSocket) {
        try {
            const token = this.extractToken(client);
                if (!token) {
                    client.disconnect();
                return;
            }
            const payload = this.authService.validateAccess(token);
      
            client.user = {
                id: payload.sub,
                login: payload.login
            };

            this.connectedUsers.set(client.id, {
                id: payload.sub,
                login: payload.login,
                socketId: client.id
            });
            this.eventBus.publish(new UserJoinedEvent(
                payload.sub,
                payload.login
            ));
        } catch (error) {
            client.disconnect();
        }
    }
  
    async handleDisconnect(client: AuthenticatedSocket) {
        const user = this.connectedUsers.get(client.id);
        if (user) {
            this.connectedUsers.delete(client.id);  
        }
    }
  

    @SubscribeMessage('send_message')
    handleMessage(client: AuthenticatedSocket, messageData: { content: string, userId: string, username: string }) {
        const user = client.user;
        this.eventBus.publish(new MessageSentEvent(
            messageData.userId,
            messageData.username, 
            messageData.content
        ));
    }

    private extractToken(client: Socket): string | null {
        const token = client.handshake.auth.token ||  client.handshake.query.token;
        return token ? String(token) : null;
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/infrastructure/redis.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { RedisAbstractConnection } from "../../../../infrastructure/redis";
import { INFRASTRUCTURE_CONSTANTS } from "../constants";
import { IConfig } from "../../../../core/application";

@Injectable()
export class RedisConnection extends RedisAbstractConnection {
    constructor(
        @Inject(INFRASTRUCTURE_CONSTANTS.CONFIG) config: IConfig
    ) {
        super(
            config,
        );
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/infrastructure/infrastructure.module.ts
================================================================
import { Module } from "@nestjs/common";
import { INFRASTRUCTURE_CONSTANTS } from "../constants";
import { ConfigService } from "./config";
import { PgConnection } from "./pg";
import { RedisConnection } from "./redis";



@Module({
    providers: [
        {provide: INFRASTRUCTURE_CONSTANTS.CONFIG, useClass: ConfigService},
        {provide: INFRASTRUCTURE_CONSTANTS.PG, useClass: PgConnection},
        {provide: INFRASTRUCTURE_CONSTANTS.REDIS, useClass: RedisConnection},
    ],
    exports: [
        INFRASTRUCTURE_CONSTANTS.CONFIG,
        INFRASTRUCTURE_CONSTANTS.PG,
        INFRASTRUCTURE_CONSTANTS.REDIS,
    ],
})
export class InfrastructureModule {}


================================================================
ФАЙЛ: ./presentation/nest/modules/infrastructure/pg.ts
================================================================
import { Injectable } from "@nestjs/common";
import { TypeOrmAbstractConnection } from "../../../../infrastructure/postgres";

@Injectable()
export class PgConnection extends TypeOrmAbstractConnection {
    constructor() {
        super();
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/infrastructure/config.ts
================================================================
import { Injectable } from "@nestjs/common";
import { ConfigAbstractService } from "../../../../core/application";

@Injectable()
export class ConfigService extends ConfigAbstractService {
    constructor() {
        super();
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/infrastructure/index.ts
================================================================
export * from './infrastructure.module';


================================================================
ФАЙЛ: ./presentation/nest/modules/constants.ts
================================================================
export const AUTH_CONSTANTS = {
    AUTH_SERVICE : 'AUTH_SERVICE',
    REGISTRATION_COMMAND: 'REGISTRATION_COMMAND',
    ACCOUNT_REPOSITORY: 'ACCOUNT_REPOSITORY',
    CRYPTO_SERVICE: 'CRYPTO_SERVICE',
    JWT_SERVICE: 'JWT_SERVICE',
    ENTRANCE_TOKEN_REPOSITORY: 'ENTRANCE_TOKEN_REPOSITORY',
}

export const INFRASTRUCTURE_CONSTANTS = {
    CONFIG : 'CONFIG',
    PG: 'PG',
    REDIS: 'REDIS',
}

export const FILE_CONSTANTS = {
    FILE_SERVICE : 'FILE_SERVICE',
    FILE_STORAGE_SERVICE: 'FILE_STORAGE_SERVICE',
    FILE_PATH_REPOSITORY: 'FILE_PATH_REPOSITORY'
}

export const EVENT_CONSTANTS = {
    EVENT_BUS : 'EVENT_BUS',
}

export const CHAT_CONSTANTS = {
    CHAT_SERVICE : 'CHAT_SERVICE',
    CHAT_GATEWAY :  'CHAT_GATEWAY'
}


================================================================
ФАЙЛ: ./presentation/nest/modules/index.ts
================================================================
export * from './app.module';
export * from './constants';


================================================================
ФАЙЛ: ./presentation/nest/modules/events/event.bus.ts
================================================================
import { Injectable } from "@nestjs/common";
import { EventBus, EventHandler } from "../../../../core/application/common/events";
import { IEvent } from "../../../..//core/domain/events/event";

@Injectable()
export class NestEventBus extends EventBus {
  private handlers = new Map<string, EventHandler<any>[]>();

  publish<T extends IEvent>(event: T): void {
    const eventHandlers = this.handlers.get(event.type) || [];
    eventHandlers.forEach(handler => handler(event));
  }

  subscribe<T extends IEvent>(eventType: string, handler: EventHandler<T>): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler);
  }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/events/event.module.ts
================================================================
import { Module } from "@nestjs/common";
import { EVENT_CONSTANTS } from "../constants";
import { NestEventBus } from "./event.bus";


@Module({
    providers: [
        {provide: EVENT_CONSTANTS.EVENT_BUS, useClass: NestEventBus}
    ],
    exports : [
        EVENT_CONSTANTS.EVENT_BUS
    ]
})
export class EventModule {}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/dto/registration.dto.ts
================================================================
import { IsString, MinLength, MaxLength, Matches, IsNotEmpty } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class RegistrationDto {
    @ApiProperty({ 
        example: 'john_doe',
        description: 'User login (5-60 characters)',
        minLength: 5,
        maxLength: 60
    })
    @IsString({ message: 'Login must be a string' })
    @IsNotEmpty({ message: 'Login cannot be empty' })
    @MinLength(5, { message: 'Login must be at least 5 characters long' })
    @MaxLength(60, { message: 'Login cannot be longer than 60 characters' })
    login: string;

    @ApiProperty({ 
        example: 'SecurePassword123',
        description: 'User password (5-60 characters)',
        minLength: 5,
        maxLength: 60
    })
    @IsString({ message: 'Password must be a string' })
    @IsNotEmpty({ message: 'Password cannot be empty' })
    @MinLength(5, { message: 'Password must be at least 5 characters long' })
    @MaxLength(60, { message: 'Password cannot be longer than 60 characters' })
    password: string;
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/dto/login.dto.ts
================================================================
import { IsString, MinLength, MaxLength, Matches } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class LoginDto {
    @ApiProperty({ 
        example: 'john_doe',
        description: 'User login (5-60 characters, letters, numbers, underscores)',
        minLength: 5,
        maxLength: 60
    })
    @IsString({ message: 'Login must be a string' })
    @MinLength(5, { message: 'Login must be at least 5 characters long' })
    @MaxLength(60, { message: 'Login cannot be longer than 60 characters' })
    login: string;

    @ApiProperty({ 
        example: 'Password123',
        description: 'User password (5-60 characters)',
        minLength: 5,
        maxLength: 60
    })
    @IsString({ message: 'Password must be a string' })
    @MinLength(5, { message: 'Password must be at least 5 characters long' })
    @MaxLength(60, { message: 'Password cannot be longer than 60 characters' })
    password: string;
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/dto/auth.response.ts
================================================================
import { ApiProperty } from '@nestjs/swagger';
import { AccountResponse } from "./account.response";
import { TokenResponse } from "./token.response";

export class AuthResponse {
    @ApiProperty({ type: TokenResponse })
    tokenResponse: TokenResponse;

    @ApiProperty({ type: AccountResponse })
    accountResponse: AccountResponse;
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/dto/token.response.ts
================================================================
import { ApiProperty } from '@nestjs/swagger';

export class TokenResponse {
    @ApiProperty({ 
        example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
        description: 'JWT access token' 
    })
    access: string;
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/dto/account.response.ts
================================================================
import { ApiProperty } from '@nestjs/swagger';

export class AccountResponse {
    @ApiProperty({ 
        example: 'john_doe',
        description: 'User login' 
    })
    login: string;
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/dto/index.ts
================================================================
export  * from './registration.dto';
export * from './auth.response';
export * from './token.response';


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/services/jwt.service.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { JwtAbstractService } from "../../../../../core/application/services";
import { INFRASTRUCTURE_CONSTANTS } from "../../constants";
import { IConfig } from "../../../../../core/application";


@Injectable()
export class JwtService extends JwtAbstractService {
    constructor(
        @Inject(INFRASTRUCTURE_CONSTANTS.CONFIG) config: IConfig
    ) {
        super(config);
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/services/auth.service.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { AuthAbstractService, ICryptoService, IJwtService } from "../../../../../core/application";
import { AUTH_CONSTANTS } from "../../constants";
import { IAccountRepository, IEntranceTokenRepository, IRegistrationCommand } from "../../../../../core/domain/auth";


@Injectable()
export class AuthService extends AuthAbstractService {
    constructor(
        @Inject(AUTH_CONSTANTS.REGISTRATION_COMMAND) registrationCommand: IRegistrationCommand,
        @Inject(AUTH_CONSTANTS.ACCOUNT_REPOSITORY) accountRepository: IAccountRepository,
        @Inject(AUTH_CONSTANTS.CRYPTO_SERVICE) cryptoService: ICryptoService,
        @Inject(AUTH_CONSTANTS.JWT_SERVICE) jwtService: IJwtService,
        @Inject(AUTH_CONSTANTS.ENTRANCE_TOKEN_REPOSITORY) entranceTokenRepository: IEntranceTokenRepository
    ) {
       super(
           registrationCommand,
            accountRepository,
            cryptoService,
            jwtService,
            entranceTokenRepository
       ); 
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/services/index.ts
================================================================
export * from './auth.service';
export * from './crypto.service';
export * from './jwt.service';


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/services/crypto.service.ts
================================================================
import { Injectable } from "@nestjs/common";
import { CryptoAbstractService } from "../../../../../core/application";

@Injectable()
export class CryptoService extends CryptoAbstractService {
    constructor() {
        super();
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/comands/registration.command.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { RegistrationAbstractCommand,TypeOrmAbstractConnection } from "../../../../../infrastructure/postgres/typeorm/";
import { INFRASTRUCTURE_CONSTANTS } from "../../constants";


@Injectable()
export class RegistrationCommand extends RegistrationAbstractCommand {
    constructor (
        @Inject(INFRASTRUCTURE_CONSTANTS.PG) pg: TypeOrmAbstractConnection
    ) {
        super(pg);
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/comands/index.ts
================================================================
export * from './registration.command';


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/controllers/auth.controller.ts
================================================================
import { Body, Controller, Inject, Param, Post, Req, Res, UseGuards, UsePipes, ValidationPipe } from "@nestjs/common";
import { AUTH_CONSTANTS } from "../../constants";
import { IAuthService } from "../../../../../core/application";
import { AuthResponse, RegistrationDto, TokenResponse } from "../dto";
import { LoginDto } from "../dto/login.dto";
import { ExtendRequest } from "../../../extends/extend.request";
import { Response } from "express";
import { AuthGuard } from "../guards";
import { ApiBearerAuth, ApiBody, ApiCookieAuth, ApiParam, ApiResponse, ApiTags,  } from "@nestjs/swagger";

@ApiTags('auth')
@Controller('auth')
export class AuthController {
    constructor(
        @Inject(AUTH_CONSTANTS.AUTH_SERVICE) private readonly authService: IAuthService
    ) {
    }

    @ApiBody({ type: RegistrationDto })
    @ApiResponse({  status: 201,  type: AuthResponse})
    @Post('/registration')
    async registration(
        @Body() dto: RegistrationDto,
        @Res({ passthrough: true }) res: Response,
    ) : Promise<AuthResponse> {
        const authResponse = await this.authService.registration(dto);
        this.setRefreshTokenCookie(
            res, 
            authResponse.tokenResponse.refresh
        );
        return {
            accountResponse: authResponse.accountResponse,
            tokenResponse: {
                access: authResponse.tokenResponse.access
            }
        }
    }

    @ApiBody({ type: LoginDto })
    @ApiResponse({  status: 201,  type: AuthResponse})
    @Post('/login')
    async login (
        @Body() dto: LoginDto,
        @Res({ passthrough: true }) res: Response,    
    ): Promise<AuthResponse> {
        const authResponse = await this.authService.login(dto);
        this.setRefreshTokenCookie(
            res, 
            authResponse.tokenResponse.refresh
        );
        return {
            accountResponse: authResponse.accountResponse,
            tokenResponse: {
                access: authResponse.tokenResponse.access
            }
        }
    }

    
    @ApiCookieAuth('refresh')
    @ApiResponse({  status: 201,  type: TokenResponse})
    @Post('refresh')
    async refresh (
        @Req() req: ExtendRequest,
        @Res({ passthrough: true }) res: Response,
    ) : Promise<TokenResponse> {
        const token : string = req.cookies?.refresh;
        const tokenResponse = await this.authService.refresh(token);
        this.setRefreshTokenCookie(
            res, 
            tokenResponse.refresh
        );
        return {
            access: tokenResponse.access
        }
    }

    @ApiBearerAuth('JWT-auth')
    @ApiResponse({ 
        status: 201, 
        schema: {
            type: 'string',
            example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'
        }
    })
    @Post('/entrance/create')
    @UseGuards(AuthGuard)
    async createEntranceToken(
        @Req() req: ExtendRequest,        
    ): Promise<string> {
        const accountId = req.account.id;
        const token = await this.authService.createEntranceToken (accountId);
        return token.id;
    }
        
    @ApiResponse({ status: 201, type: AuthResponse})
    @ApiParam({ 
        name: 'token', 
        type: 'string', 
        description: 'Entrance token UUID',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'
    })
    @Post('/entrance/:token')
    async entrance (
        @Param('token') token: string,
        @Res({passthrough: true}) res: Response
    ): Promise<AuthResponse> {
        const authResponse = await this.authService.loginWithEntranceToken(token);    
        this.setRefreshTokenCookie(res,authResponse.tokenResponse.refresh);
        return {
            accountResponse: authResponse.accountResponse,
            tokenResponse: {
                access: authResponse.tokenResponse.access
            }
        }
    }
        
    private setRefreshTokenCookie(response: Response, token: string): void {
    response.cookie('refresh', token, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60 * 1000,
      path: '/auth/refresh',
    });
  }
}




================================================================
ФАЙЛ: ./presentation/nest/modules/auth/controllers/index.ts
================================================================
export * from './auth.controller';


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/auth.module.ts
================================================================
import { Module } from "@nestjs/common";
import { AUTH_CONSTANTS } from "../constants";
import { AccountRepository, EntranceTokenRepository } from "./repositories";
import { AuthService, CryptoService, JwtService } from "./services";
import { RegistrationCommand } from "./comands";
import { AuthController } from "./controllers";
import { AuthGuard } from "./guards";
import { InfrastructureModule } from "../infrastructure";


@Module({
    imports: [InfrastructureModule],
    providers: [
        {provide: AUTH_CONSTANTS.ACCOUNT_REPOSITORY, useClass: AccountRepository},
        {provide: AUTH_CONSTANTS.AUTH_SERVICE, useClass: AuthService},
        {provide: AUTH_CONSTANTS.CRYPTO_SERVICE, useClass: CryptoService},
        {provide: AUTH_CONSTANTS.ENTRANCE_TOKEN_REPOSITORY, useClass: EntranceTokenRepository},
        {provide: AUTH_CONSTANTS.JWT_SERVICE, useClass: JwtService},
        {provide: AUTH_CONSTANTS.REGISTRATION_COMMAND, useClass: RegistrationCommand},
        AuthGuard
    ],
    controllers: [
        AuthController
    ],
    exports: [
        AuthGuard, 
        AUTH_CONSTANTS.AUTH_SERVICE
    ]
})
export class AuthModule {}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/repositories/account.repository.ts
================================================================
import { AccountAbstractRepository } from "../../../../../infrastructure/postgres";
import { Injectable } from "@nestjs/common";

@Injectable()
export class AccountRepository extends AccountAbstractRepository {
    constructor() {
        super();
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/repositories/index.ts
================================================================
export * from './account.repository';
export * from './entranceToken.repository';


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/repositories/entranceToken.repository.ts
================================================================
import { Inject, Injectable } from "@nestjs/common";
import { EntranceTokenAbstractRepository, RedisAbstractConnection } from "../../../../../infrastructure/redis";
import { INFRASTRUCTURE_CONSTANTS } from "../../constants";
import { IConfig } from "../../../../../core/application";

@Injectable()
export class EntranceTokenRepository extends EntranceTokenAbstractRepository {
    constructor(
        @Inject(INFRASTRUCTURE_CONSTANTS.REDIS) redis: RedisAbstractConnection,
        @Inject(INFRASTRUCTURE_CONSTANTS.CONFIG) config: IConfig
   ) {
        super(
            redis,
            config
        );
    }
}


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/index.ts
================================================================
export * from './auth.module';


================================================================
ФАЙЛ: ./presentation/nest/modules/auth/guards/auth.guard.ts
================================================================
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
} from '@nestjs/common';

import { AUTH_CONSTANTS } from '../../constants';
import { CommonError, IAuthService } from '../../../../../core/application';
import { ExtendRequest } from '../../../extends/extend.request';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    @Inject(AUTH_CONSTANTS.AUTH_SERVICE)
    private readonly authService: IAuthService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<ExtendRequest>();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      CommonError.Unauthorized('token not found');
    }

    try {
      const payload =  this.authService.validateAccess(token);
      request.account = {
        id: payload.sub,
        login: payload.login
      };
      return true;
    } catch (e) {
      CommonError.Unauthorized('token not valid');
    }
  }

  private extractTokenFromHeader(request: ExtendRequest): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}



================================================================
ФАЙЛ: ./presentation/nest/modules/auth/guards/index.ts
================================================================
export * from './auth.guard';


================================================================
ФАЙЛ: ./presentation/nest/index.ts
================================================================
export * from './bootstrap';



